DPは式か図を書く
二分探索できるか
操作をマージして高速化できるか
周期があるか
収束するまでにどのくらいかかるか
解の個数を考える

全てのパターンに対してのコストを計算
  コストがkになる場合
  ある状態がコストに何回寄与するか
  全体から条件を満たさない場合を引く
  あるものをk個持っている状態のコストがkの場合, 〇〇個以上持っている状態を数える

Aから操作を行ってBにしたい場合, 可逆ならばBも操作していい
操作を行うときに注目する点
  全体の偶奇, xor
  隣接する項の差分(辺クエリ <-> 頂点クエリ)
  gcd
  操作回数の下界, 上界
2a - b : aを中心としてbと対称な点

区間の数だけ操作を行う問題で, 区間全体の数はO(N^2)であるがよく考えると必要な区間はO(N)個になるか
  [l, r)より真に小さい区間が条件を満たす -> [l, r)は必要ない

操作を行う必要が出た時に, 過去のいずれかのタイミングで操作した場合と置き換える

鏡面反射 反射した後の直線は, 鏡面がなかった場合と比べて鏡面に対して対称

円環が関わる問題は元の列を2つ連結させると実装が楽

木の全てのパターンについて
  LCAを固定
  距離を固定
  辺を固定

条件を満たす区間を数える
  lまたはrを固定
  結果を固定した時の[l, r)を求める

状態Aと状態Bが1対1で対応しているか

Ai, Ai+1が等しいようなiについて -> iの偶奇で反転しておくと隣接swapなどに言い換えられる

2変数dijkstra

中央値を決めうつ

タプルを辺とみなす
タプルを空間の点とみなす

combinationを言い換え
  階乗
  二項係数の変形
  グリッド上の経路

斜線 -> ジグザグに直す

直径が偶数なら中心の点が一意に定まる奇数なら中心の辺が一意に定まる

2人ゲームでmod2を考える

ある組み合わせが丁度1回だけ数えられ, 全ての組み合わせが数えられるようにする
全ての場合のスコアの総和, スコアが何かの積である場合 -> 2項係数

操作回数の期待値
= (終端でない状態に到達する確率) * (次の状態に遷移するまでの試行回数)


fix
代数的構造
sanitizer 再帰に引っかかる
最悪ケースの速度改善 kd-tree, hashtable